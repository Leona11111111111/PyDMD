<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pydmd.paramdmd &mdash; PyDMD 0.4 documentation</title><link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> PyDMD
          </a>
              <div class="version">
                0.4
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../code.html">Code Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contact.html">Contact</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">How to contribute</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../LICENSE.html">License</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">PyDMD</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>pydmd.paramdmd</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pydmd.paramdmd</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module for the parametric Dynamic Mode Decomposition.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>


<div class="viewcode-block" id="ParametricDMD"><a class="viewcode-back" href="../../paramdmd.html#pydmd.paramdmd.ParametricDMD">[docs]</a><span class="k">class</span> <span class="nc">ParametricDMD</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implementation of the parametric Dynamic Mode Decomposition proposed in</span>
<span class="sd">    arXiv:2110.09155v1. Both the *monolithic* and *partitioned* approaches are</span>
<span class="sd">    available, see the documentation of the parameter `dmd` for more details.</span>

<span class="sd">    :param dmd: Instance(s) of :class:`dmdbase.DMDBase`, used by the</span>
<span class="sd">        paramtric DMD for the prediction of future spatial modal coefficients.</span>
<span class="sd">        If `dmd` is a `list` the *partitioned* approach is selected, in this</span>
<span class="sd">        case the number of parameters in the training set should be equal to</span>
<span class="sd">        the number of DMD instances provided. If `dmd` is not a list, we employ</span>
<span class="sd">        the monolithic approach.</span>
<span class="sd">    :type dmd: DMDBase</span>
<span class="sd">    :param spatial_pod: Instance of an object usable for the generation of a</span>
<span class="sd">        ROM of the given dataset (see for instance the class</span>
<span class="sd">        `POD &lt;https://mathlab.github.io/EZyRB/pod.html&gt;`_ from the Python</span>
<span class="sd">        library `EZyRB &lt;https://github.com/mathLab/EZyRB&gt;`_).</span>
<span class="sd">    :param approximation: An interpolator following the standard</span>
<span class="sd">        learning-prediction pattern (`fit()` -&gt; `predict()`). For some</span>
<span class="sd">        convenient wrappers see those implemented in</span>
<span class="sd">        `EZyRB &lt;https://github.com/mathLab/EZyRB&gt;`_).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dmd</span><span class="p">,</span> <span class="n">spatial_pod</span><span class="p">,</span> <span class="n">approximation</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dmd</span> <span class="o">=</span> <span class="n">dmd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_spatial_pod</span> <span class="o">=</span> <span class="n">spatial_pod</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_approximation</span> <span class="o">=</span> <span class="n">approximation</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_training_parameters</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ntrain</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time_instants</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_space_dim</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_partitioned</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return `True` if this instance is partitioned, `False` if it is</span>
<span class="sd">        monolithic.</span>

<span class="sd">        :type: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dmd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dmd</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_reference_dmd</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        An object used as a reference for several properties like</span>
<span class="sd">        :func:`dmd_time` and :func:`dmd_timesteps`. If this instance is</span>
<span class="sd">        monolithic the returned value is `self._dmd`, otherwise it is the first</span>
<span class="sd">        item of the list `self._dmd`.</span>

<span class="sd">        :return: The object used as a reference.</span>
<span class="sd">        :rtype: pydmd.DMDBase</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_partitioned</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dmd</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dmd_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The time dictionary used by the reference DMD instance (see also</span>
<span class="sd">        :func:`_reference_dmd`). Note that when you set this attribute the</span>
<span class="sd">        value is set only for the reference DMD (see :func:`_reference_dmd`),</span>
<span class="sd">        however when :func:`_predict_modal_coefficients` is called the values</span>
<span class="sd">        of all DMDs become consistent.</span>

<span class="sd">        :getter: Return the time dictionary used by the reference DMD instance.</span>
<span class="sd">        :setter: Set the given time dictionary in the field `dmd_time` for all</span>
<span class="sd">            DMD instances.</span>
<span class="sd">        :type: pydmd.dmdbase.DMDTimeDict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference_dmd</span><span class="o">.</span><span class="n">dmd_time</span>

    <span class="nd">@dmd_time</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">dmd_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reference_dmd</span><span class="o">.</span><span class="n">dmd_time</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dmd_timesteps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The timesteps in the output of this instance, which coincides with the</span>
<span class="sd">        timesteps in the output of the reference of this instance (see</span>
<span class="sd">        :func:`_reference_dmd`).</span>

<span class="sd">        :return: The timesteps in the output of this instance.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference_dmd</span><span class="o">.</span><span class="n">dmd_timesteps</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">original_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The original time dictionary used by this instance, which coincides</span>
<span class="sd">        with the original dictionary used by the reference of this instance</span>
<span class="sd">        (see :func:`_reference_dmd`).</span>

<span class="sd">        :return: The original time dictionary used by this instance.</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference_dmd</span><span class="o">.</span><span class="n">original_time</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">original_timesteps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The original timesteps in the input fed to this instance, which</span>
<span class="sd">        coincides with the original timesteps in the input fed to the reference</span>
<span class="sd">        of this instance (see :func:`_reference_dmd`).</span>

<span class="sd">        :return: The original timesteps in the input fed to this instance.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference_dmd</span><span class="o">.</span><span class="n">original_timesteps</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">training_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The original parameters passed when `self.fit` was called, represented</span>
<span class="sd">        as a 2D array (the index of the parameter vary along the first</span>
<span class="sd">        dimension).</span>

<span class="sd">        :type: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_training_parameters</span>

    <span class="k">def</span> <span class="nf">_set_training_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the value of `self._original_parameters`, while checking that the</span>
<span class="sd">        value provided is a 2D array.</span>

<span class="sd">        :param numpy.ndarray: A 2D array which contains the original</span>
<span class="sd">            parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">params</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">params</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Parameters must be stored in 2D arrays.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_training_parameters</span> <span class="o">=</span> <span class="n">params</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The new parameters to be used in `reconstructed_data`, represented</span>
<span class="sd">        as a 2D array (the index of the parameter vary along the first</span>
<span class="sd">        dimension).</span>

<span class="sd">        :getter: Return the current parameters.</span>
<span class="sd">        :setter: Change the current parameters.</span>
<span class="sd">        :type: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_parameters&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="nd">@parameters</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">value</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Parameters must be stored in 2D arrays.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_arrange_parametric_snapshots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Arrange the given parametric snapshots (see :func:`fit` for an overview</span>
<span class="sd">        of the shape of `X`) into a 2D matrix in which the shape is distributed</span>
<span class="sd">        as follows:</span>

<span class="sd">        - 0: Space;</span>
<span class="sd">        - 1: Time/Parameter.</span>

<span class="sd">        Time varies faster than the parameter along the columns of the matrix.</span>

<span class="sd">        An overview of the shape of the resulting matrix:</span>

<span class="sd">         .. math::</span>

<span class="sd">            M = \\begin{bmatrix}</span>
<span class="sd">                    x_1(t_1,\\mu_1) &amp; \dots &amp; x_1(t_n,\\mu_1) &amp; x_1(t_1,\\mu_1)</span>
<span class="sd">                        &amp; \dots &amp; x_1(t_{n-1},\\mu_k) &amp; x_1(t_n,\\mu_k)\\\\</span>
<span class="sd">                    \\vdots &amp; \\dots &amp; \\vdots &amp; \\vdots &amp; \\dots &amp; \\vdots</span>
<span class="sd">                        &amp; \\dots\\\\</span>
<span class="sd">                    x_m(t_1,\\mu_1) &amp; \dots &amp; x_m(t_n,\\mu_1) &amp; x_m(t_1,\\mu_1)</span>
<span class="sd">                        &amp; \dots &amp; x_m(t_{n-1},\\mu_k) &amp; x_m(t_n,\\mu_k)</span>
<span class="sd">                \\end{bmatrix}</span>

<span class="sd">        :math:`x(t, \mu) \in \mathbb{R}^m` is the functon which represents the</span>
<span class="sd">        parametric system at time :math:`t` with the parameter :math:`\\mu`.</span>

<span class="sd">        :param X: Parametric snapshots.</span>
<span class="sd">        :type X: numpy.ndarray</span>
<span class="sd">        :return: The given parametric snapshots rearranged in a 2D matrix.</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_space_dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_instants</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ntrain</span><span class="p">),</span>
            <span class="s2">&quot;F&quot;</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_training_modal_coefficients</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space_timemu</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the POD modal coefficient from the given matrix, and put</span>
<span class="sd">        the resulting coefficients (along with their time evolution in matrix</span>
<span class="sd">        form) into a list.</span>

<span class="sd">        In symbols, from the given matrix :math:`X^x_{t,\mu} \in</span>
<span class="sd">        \mathbb{R}^{m \\times nk}` we compute the modal</span>
<span class="sd">        coefficients corresponding to its columns. At this point we have</span>
<span class="sd">        something like this:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \\widetilde{X}^s_{t,\mu} = \\begin{bmatrix}</span>
<span class="sd">                    \\widetilde{x}_1(t_1,\\mu_1), &amp; \dots &amp;</span>
<span class="sd">                        \\widetilde{x}_1(t_n,\\mu_1), &amp;</span>
<span class="sd">                        \\widetilde{x}_1(t_1,\\mu_1), &amp; \dots &amp;</span>
<span class="sd">                        \\widetilde{x}_1(t_{n-1},\\mu_k), &amp;</span>
<span class="sd">                        \\widetilde{x}_1(t_n,\\mu_k)\\\\</span>
<span class="sd">                    \\vdots &amp; \\dots &amp; \\vdots &amp; \\vdots &amp; \\dots &amp; \\vdots &amp;</span>
<span class="sd">                        \\dots\\\\</span>
<span class="sd">                    \\widetilde{x}_p(t_1,\\mu_1), &amp; \dots &amp; x_p(t_n,\\mu_1) &amp;</span>
<span class="sd">                        \\widetilde{x}_p(t_1,\\mu_1), &amp; \dots &amp;</span>
<span class="sd">                        \\widetilde{x}_p(t_{n-1},\\mu_k), &amp;</span>
<span class="sd">                        \\widetilde{x}_p(t_n,\\mu_k)</span>
<span class="sd">                \\end{bmatrix} \in \mathbb{R}^{p \\times nk}</span>

<span class="sd">        Detecting the sub-matrices corresponding to the time evolution of the</span>
<span class="sd">        POD modal coefficients corresponding to a particular realization of the</span>
<span class="sd">        system for some parameter :math:`\\mu_i`, we may rewrite this matrix as</span>
<span class="sd">        follows:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \\widetilde{X}^s_{t,\mu} = \\begin{bmatrix}</span>
<span class="sd">                    \\widetilde{X}_{\\mu_1}, &amp; \dots &amp; \\widetilde{X}_{\\mu_1}</span>
<span class="sd">            \\end{bmatrix}</span>

<span class="sd">        The returned list contains the matrices</span>
<span class="sd">        :math:`\\widetilde{X}_{\\mu_i} \in \\mathbb{p \\times n}`.</span>

<span class="sd">        :param space_timemu: A matrix containing parametric/time snapshots as</span>
<span class="sd">            returned by :func:`_arrange_parametric_snapshots`.</span>
<span class="sd">        :type space_timemu: numpy.ndarray</span>
<span class="sd">        :return: A list of matrices. Each matrix contain the time evolution of</span>
<span class="sd">            the POD modal coefficients corresponding to a parameter from the</span>
<span class="sd">            training set.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">spatial_modal_coefficients</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spatial_pod</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
            <span class="n">space_timemu</span>
        <span class="p">)</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">space_timemu</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">spatial_modal_coefficients</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ntrain</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_fit_dmd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">training_modal_coefficients</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Train the DMD instance(s) on the given training modal coefficients.</span>

<span class="sd">        :param training_modal_coefficients: Matrix (or list of matrices) of</span>
<span class="sd">            modal coefficients. The time varies along columns.</span>
<span class="sd">        :type training_modal_coefficients: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_partitioned</span><span class="p">:</span>
            <span class="c1"># partitioned parametric DMD</span>
            <span class="k">for</span> <span class="n">dmd</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dmd</span><span class="p">,</span> <span class="n">training_modal_coefficients</span><span class="p">):</span>
                <span class="n">dmd</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spacemu_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">training_modal_coefficients</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dmd</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">spacemu_time</span><span class="p">)</span>

<div class="viewcode-block" id="ParametricDMD.fit"><a class="viewcode-back" href="../../paramdmd.html#pydmd.paramdmd.ParametricDMD.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">training_parameters</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the parametric Dynamic Modes Decomposition from the input data</span>
<span class="sd">        stored in the array `X`. The shape of the parameter `X` must be</span>
<span class="sd">        used as follows:</span>

<span class="sd">        - 0: Parameters;</span>
<span class="sd">        - 1: Time;</span>
<span class="sd">        - 2: Space.</span>

<span class="sd">        Which means that along the first axis the parameter varies, along the</span>
<span class="sd">        second axis varies the time, and along the last axis varies the</span>
<span class="sd">        space (i.e. the dimensionality of a single snapshot of the dynamical</span>
<span class="sd">        system).</span>

<span class="sd">        The second parameter contains the list of training parameters</span>
<span class="sd">        corresponding to the given array of snapshots `X`. It is fundamental</span>
<span class="sd">        that `X.shape[0] == len(training_parameters)`, otherwise the number</span>
<span class="sd">        of parametric snapshots would be different than the number of training</span>
<span class="sd">        parameters, which obviously cannot happen.</span>

<span class="sd">        :param numpy.ndarray X: The input snapshots, in multiple time instants</span>
<span class="sd">            and parameters.</span>
<span class="sd">        :param numpy.ndarray training_parameters: The parameters used for the</span>
<span class="sd">            training, corresponding to the snapshots in `X`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">training_parameters</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Unexpected number of snapshots for the given&quot;</span>
                <span class="s2">&quot;parameters. Received </span><span class="si">{}</span><span class="s2"> parameters, and </span><span class="si">{}</span><span class="s2"> snapshots&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">training_parameters</span><span class="p">),</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># we store these values for faster access</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ntrain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_instants</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_space_dim</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_partitioned</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ntrain</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dmd</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid number of DMD instances provided: &quot;</span>
                <span class="s2">&quot;expected n_train=</span><span class="si">{}</span><span class="s2">, got </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ntrain</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dmd</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># store the training parameters: they will be used in</span>
        <span class="c1"># `reconstructed_data`</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_training_parameters</span><span class="p">(</span><span class="n">training_parameters</span><span class="p">)</span>

        <span class="c1"># arrange the parametric snapshots in a convenient way to perform POD</span>
        <span class="n">space_timemu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arrange_parametric_snapshots</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

        <span class="c1"># obtain POD modal coefficients from the training set</span>
        <span class="n">training_modal_coefficients</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_training_modal_coefficients</span><span class="p">(</span>
            <span class="n">space_timemu</span>
        <span class="p">)</span>

        <span class="c1"># fit DMD(s) with POD modal coefficients</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fit_dmd</span><span class="p">(</span><span class="n">training_modal_coefficients</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">reconstructed_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the reconstructed data, for the time instants specified in</span>
<span class="sd">        `dmd_time`, and the parameters stored in `parameters`.</span>

<span class="sd">        The shape of the returned data is distributed as follows:</span>

<span class="sd">        - 0: Parameters;</span>
<span class="sd">        - 1: Time;</span>
<span class="sd">        - 2: Space.</span>

<span class="sd">        :return: Snapshots predicted/interpolated using parametric Dynamic Mode</span>
<span class="sd">            Decomposition.</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">forecasted_modal_coefficients</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predict_modal_coefficients</span><span class="p">()</span>
        <span class="n">interpolated_pod_modal_coefficients</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_interpolate_missing_modal_coefficients</span><span class="p">(</span>
                <span class="n">forecasted_modal_coefficients</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="n">interpolated_pod_modal_coefficients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span>
            <span class="n">interpolated_pod_modal_coefficients</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_spatial_pod</span><span class="o">.</span><span class="n">expand</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">interpolated_pod_modal_coefficients</span>
        <span class="p">)</span>

<div class="viewcode-block" id="ParametricDMD.save"><a class="viewcode-back" href="../../paramdmd.html#pydmd.paramdmd.ParametricDMD.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the object to `fname` using the pickle module.</span>

<span class="sd">        :param str fname: the name of file where the reduced order model will</span>
<span class="sd">            be saved.</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; from pydmd import ParametricDMD</span>
<span class="sd">        &gt;&gt;&gt; pdmd = ParametricDMD(...) #  Construct here the rom</span>
<span class="sd">        &gt;&gt;&gt; pdmd.fit(...)</span>
<span class="sd">        &gt;&gt;&gt; pdmd.save(&#39;pydmd.pdmd&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span></div>

<div class="viewcode-block" id="ParametricDMD.load"><a class="viewcode-back" href="../../paramdmd.html#pydmd.paramdmd.ParametricDMD.load">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load the object from `fname` using the pickle module.</span>

<span class="sd">        :return: The `ReducedOrderModel` loaded</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; from pydmd import ParametricDMD</span>
<span class="sd">        &gt;&gt;&gt; pdmd = ParametricDMD.load(&#39;pydmd.pdmd&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(pdmd.reconstructed_data)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
            <span class="n">dmd</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dmd</span></div>

    <span class="k">def</span> <span class="nf">_predict_modal_coefficients</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Predict future spatial modal coefficients in the time instants in</span>
<span class="sd">        `dmd_time`.</span>

<span class="sd">        :return: Predicted spatial modal coefficients.</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_partitioned</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">dmd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dmd</span><span class="p">:</span>
                <span class="c1"># we want to &quot;bound&quot; this DMD objects &quot;dmd_time&quot;</span>
                <span class="n">dmd</span><span class="o">.</span><span class="n">dmd_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference_dmd</span><span class="o">.</span><span class="n">dmd_time</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_partitioned</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">dmd</span><span class="p">:</span> <span class="n">dmd</span><span class="o">.</span><span class="n">reconstructed_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dmd</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dmd</span><span class="o">.</span><span class="n">reconstructed_data</span>

    <span class="k">def</span> <span class="nf">_interpolate_missing_modal_coefficients</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">forecasted_modal_coefficients</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolate spatial modal coefficients for the (untested) parameters</span>
<span class="sd">        stored in `parameters`. The interpolation uses the interpolator</span>
<span class="sd">        provided in the constructor of this instance.</span>

<span class="sd">        The returned value is a 3D tensor, its shape is used as follows:</span>

<span class="sd">        - 0: Time;</span>
<span class="sd">        - 1: Parameters;</span>
<span class="sd">        - 2: POD reduced space.</span>

<span class="sd">        :param numpy.ndarray forecasted_modal_coefficients: An array of spatial</span>
<span class="sd">            modal coefficients for tested parameters.</span>
<span class="sd">        :return: An array of (interpolated) spatial modal coefficients for</span>
<span class="sd">            untested parameters.</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">forecasted_modal_coefficients</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dmd_timesteps</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid number of time instants provided: &quot;</span>
                <span class="s2">&quot;expected </span><span class="si">{}</span><span class="s2">, got </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">forecasted_modal_coefficients</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dmd_timesteps</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="n">approx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_approximation</span>

        <span class="n">forecasted_modal_coefficients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">forecasted_modal_coefficients</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ntrain</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">def</span> <span class="nf">interpolate_future_pod_coefficients</span><span class="p">(</span><span class="n">future_training_coefficients</span><span class="p">):</span>
            <span class="n">approx</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">training_parameters</span><span class="p">,</span> <span class="n">future_training_coefficients</span><span class="o">.</span><span class="n">T</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">approx</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span>
                <span class="nb">map</span><span class="p">(</span>
                    <span class="n">interpolate_future_pod_coefficients</span><span class="p">,</span>
                    <span class="n">forecasted_modal_coefficients</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright Copyright 2017-2021, PyDMD contributors.
      <span class="lastupdated">Last updated on Apr 21, 2022.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>